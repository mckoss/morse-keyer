{"version":3,"file":"morse-tree.js","sourceRoot":"","sources":["../src/morse-tree.ts"],"names":[],"mappings":"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","sourcesContent":["import { MorseTable, symbolCategory } from './morse.js';\n\nexport { makeMorseTree, rotate, findPosition };\n\nconst WIDTH = 4;\nconst HEIGHT = 4;\nconst SYM_RADIUS = 0.1;\nconst NUDGE_BASELINE = -SYM_RADIUS * 0.2;\n\nfunction makeMorseTree(symbols: MorseTable): string {\n    let result = `<svg class=\"morse-tree\" viewBox=\"${-WIDTH/2} ${-HEIGHT/2} ${WIDTH} ${HEIGHT}\">`;\n    result += `\\n<style>\n        circle.start {\n            fill: green;\n            stroke: none;\n            r: ${SYM_RADIUS/2};\n        }\n\n        circle.letter {\n            fill: white;\n            stroke: black;\n            stroke-width: 0.01;\n            r: ${SYM_RADIUS};\n        }\n\n        circle.digit {\n            fill: lightgray;\n            stroke: black;\n            stroke-width: 0.01;\n            r: ${SYM_RADIUS};\n        }\n\n        circle.symbol {\n            fill: tan;\n            stroke: black;\n            stroke-width: 0.01;\n            r: ${SYM_RADIUS};\n        }\n\n        text {\n            font-size: ${SYM_RADIUS * 1.5}px;\n            text-anchor: middle;\n            dominant-baseline: mathematical;\n        }\n\n        line.dot {\n            stroke-width: ${SYM_RADIUS / 3};\n            stroke-linecap: round;\n            stroke: red;\n        }\n\n        line.dash {\n            stroke-width: ${SYM_RADIUS / 3};\n            stroke-linecap: round;\n            stroke: black;\n        }\n    </style>\n    `;\n\n    const cache: Set<string> = new Set();\n\n    for (const [letter, morse] of Object.entries(symbols)) {\n        for (let i = 1; i <= morse.length; i++) {\n            const prefix = morse.slice(0, i);\n            if (!cache.has(prefix)) {\n                result += terminalSegment(prefix);\n                cache.add(prefix);\n            }\n        }\n    }\n\n    for (const [letter, morse] of Object.entries(symbols)) {\n        const [x, y] = findPosition(morse);\n        result += `\\n<circle class=\"${symbolCategory(letter)}\" cx=\"${x}\" cy=\"${y}\" />`;\n        result += `\\n<text x=\"${x}\" y=\"${y + NUDGE_BASELINE}\">${letter}</text>`;\n    }\n\n    result += `\\n<circle class=\"start\" cx=\"0\" cy=\"0\" />`;\n\n    result += `\\n</svg>`;\n\n    return result;\n}\n\ntype Coord = [number, number];\n\n// Poistion of letter in a 2d quadtree rooted at the origin.\n// By scanning the morse code string, each dot traverses the\n// left branch and each dash traverses the right branch.\nfunction findPosition(morse: string): Coord {\n    let result = [0, 0];\n    let dir: Coord = [0, -1];\n    let scale = WIDTH / 4;\n    let isSquare = true;\n    let pos: Coord = [0, 0];\n\n    for (let c of morse) {\n        let turn = c === '.' ? 1 : -1;\n        dir = rotate(dir, turn);\n        pos = add(pos, mult(dir, scale));\n        if (isSquare) {\n            isSquare = false;\n        } else {\n            scale /= 2;\n            isSquare = true;\n        }\n    }\n\n    return pos;\n}\n\nfunction terminalSegment(morse: string): string {\n    if (morse.length === 0) {\n        return '';\n    }\n    const cls = morse.endsWith('.') ? 'dot' : 'dash';\n    const p1 = findPosition(morse.slice(0, -1));\n    const p2 = findPosition(morse);\n    return `<line class=\"${cls}\" x1=\"${p1[0]}\" y1=\"${p1[1]}\" x2=\"${p2[0]}\" y2=\"${p2[1]}\" />`;\n}\n\n// Rotate a vector by 90 degrees counterclockwise for each turn.\n// Turns can be positive or negative.\n// Assume a left-handed coordinate system (y-axis points down).\nfunction rotate(dir: Coord, turns: number): Coord {\n    const COS = [1, 0, -1, 0];\n    const SIN = [0, -1, 0, 1];\n\n    turns = turns % 4;\n    if (turns < 0) {\n        turns += 4;\n    }\n\n    const x = dir[0] * COS[turns] - dir[1] * SIN[turns];\n    const y = dir[0] * SIN[turns] + dir[1] * COS[turns];\n\n    return [x, y];\n}\n\nfunction add(a: Coord, b: Coord): Coord {\n    return [a[0] + b[0], a[1] + b[1]];\n}\n\nfunction mult(a: Coord, scalar: number): Coord {\n    return [a[0] * scalar, a[1] * scalar];\n}\n"]}